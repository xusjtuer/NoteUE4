// Fill out your copyright notice in the Description page of Project Settings.


#include "K2Node_ArraySort.h"
#include "EdGraphSchema_K2.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EditorCategoryUtils.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "AwesomeFunctionLibrary.h"


#define LOCTEXT_NAMESPACE "K2Node_ArraySort"

namespace ArraySortHelper
{
	const FName TargetArrayPinName = "TargetArray";
	const FName PropertyNamePinName = "PropertyName";
	const FName AscendingPinName = "bAscending";
}

UK2Node_ArraySort::UK2Node_ArraySort(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	NodeTooltip = LOCTEXT("NodeTooltip", "Attempts to sort array");
}

void UK2Node_ArraySort::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Add execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	// TargetArray pin
	UEdGraphNode::FCreatePinParams ArrayPinParams;
	ArrayPinParams.ContainerType = EPinContainerType::Array;
	UEdGraphPin* TargetArrayPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, ArraySortHelper::TargetArrayPinName, ArrayPinParams);
	SetPinToolTip(*TargetArrayPin, LOCTEXT("TargetArrayPinDescription", "Target array to sort"));

	// PropertyName pin
	UEdGraphPin* PropertyNamePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, ArraySortHelper::PropertyNamePinName);
	// Sets the autogenerated default value for a pin using the default for that type
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(PropertyNamePin);
	SetPinToolTip(*PropertyNamePin, LOCTEXT("PropertyNamePinDescription", "The name of the row to set from the TargetArray"));

	// Ascending pin
	UEdGraphPin* AscendingPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, ArraySortHelper::AscendingPinName);
	// Sets the autogenerated default value for a pin
	K2Schema->SetPinAutogeneratedDefaultValue(AscendingPin, TEXT("true"));
	SetPinToolTip(*AscendingPin, LOCTEXT("AscendingPinDescription", "If true, sort by ascending order."));

	Super::AllocateDefaultPins();
}

void UK2Node_ArraySort::SetPinToolTip(UEdGraphPin& MutatablePin, const FText& PinDescription) const
{
	MutatablePin.PinToolTip = UEdGraphSchema_K2::TypeToText(MutatablePin.PinType).ToString();

	UEdGraphSchema_K2 const* const K2Schema = Cast<const UEdGraphSchema_K2>(GetSchema());
	if (K2Schema != nullptr)
	{
		MutatablePin.PinToolTip += TEXT(" ");
		MutatablePin.PinToolTip += K2Schema->GetPinDisplayName(&MutatablePin).ToString();
	}

	MutatablePin.PinToolTip += FString(TEXT("\n")) + PinDescription.ToString();
}


void UK2Node_ArraySort::RefreshPropertyNameOptions()
{
	// Update default value of PropertyNamePin
	SetDefaultValueOfPropertyNamePin();

	// When the TargetArray pin gets a new value assigned, we need to update the Slate UI so that SGraphNodeCallParameterCollectionFunction will update the ParameterName drop down
	UEdGraph* Graph = GetGraph();
	Graph->NotifyGraphChanged();
}

/** Get sortable property name form TargetArrayPin->PinType.PinSubCategoryObject */
TArray<FString> UK2Node_ArraySort::GetPropertyNames()
{
	TArray<FString> PropertyNames;

	UEdGraphPin* TargetArrayPin = GetTargetArrayPin();

	if (TargetArrayPin && TargetArrayPin->LinkedTo.Num() > 0)
	{
		UEdGraphPin* LinkArrayPin = TargetArrayPin->LinkedTo[0];
		// The type of inner property of TargetArrayPin is structure
		if (UScriptStruct* InnerStruct = Cast<UScriptStruct>(LinkArrayPin->PinType.PinSubCategoryObject.Get()))
		{
			for (TFieldIterator<const FProperty> It(InnerStruct); It; ++It)
			{
				const FProperty* BaseProp = *It;
				if (const FEnumProperty* EnumProp = CastField<const FEnumProperty>(BaseProp))
				{
					PropertyNames.Add(BaseProp->GetAuthoredName());
				}
				else if (const FNumericProperty* NumProp = CastField<const FNumericProperty>(BaseProp))
				{
					PropertyNames.Add(BaseProp->GetAuthoredName());
				}
			}
		}
		// The type of inner property of TargetArrayPin is Blueprint & C++ class
		else if (UClass* InnerObjClass = Cast<UClass>(LinkArrayPin->PinType.PinSubCategoryObject.Get()))
		{
			for (TFieldIterator<const FProperty> It(InnerObjClass); It; ++It)
			{
				const FProperty* BaseProp = *It;
				if (const FEnumProperty* EnumProp = CastField<const FEnumProperty>(BaseProp))
				{
					PropertyNames.Add(BaseProp->GetAuthoredName());
				}
				else if (const FNumericProperty* NumProp = CastField<const FNumericProperty>(BaseProp))
				{
					PropertyNames.Add(BaseProp->GetAuthoredName());
				}
			}
		}
	}
	return PropertyNames;
}


void UK2Node_ArraySort::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	// actions get registered under specific object-keys; the idea is that 
	// actions might have to be updated (or deleted) if their object-key is  
	// mutated (or removed)... here we use the node's class (so if the node 
	// type disappears, then the action should go with it)
	UClass* ActionKey = GetClass();
	// to keep from needlessly instantiating a UBlueprintNodeSpawner, first   
	// check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the 
	// registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

FText UK2Node_ArraySort::GetMenuCategory() const
{
	return FEditorCategoryUtils::GetCommonCategory(FCommonEditorCategory::Utilities);
}


void UK2Node_ArraySort::PinDefaultValueChanged(UEdGraphPin* ChangedPin)
{
	if (ChangedPin && (ChangedPin->PinName == ArraySortHelper::TargetArrayPinName))
	{
		//RefreshInputPinType();
		//RefreshPropertyNamePinDefaultValue();
		//RefreshPropertyNameOptions();
	}
}

void UK2Node_ArraySort::SetDefaultValueOfPropertyNamePin()
{
	GetPropertyNames();
	UEdGraphPin* PropertyNamePin = GetPropertyNamePin();
	FName ArrayPinCategory = GetTargetArrayPin()->PinType.PinCategory;

	if (PropertyNamePin && (ArrayPinCategory == UEdGraphSchema_K2::PC_Object || ArrayPinCategory == UEdGraphSchema_K2::PC_Struct))
	{
		// Get optional values of PropertyNamePin
		TArray<FString> ArrayPropNames = GetPropertyNames();
		if (ArrayPropNames.Num() > 0 && !ArrayPropNames.Contains(PropertyNamePin->DefaultValue))
		{
			//Set default value of PropertyNamePin 
			PropertyNamePin->DefaultValue = ArrayPropNames[0];
		}
	}
}

FText UK2Node_ArraySort::GetTooltipText() const
{
	return NodeTooltip;
}


FText UK2Node_ArraySort::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("ListViewTitle", "K2 Array Sort");
}

void UK2Node_ArraySort::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UEdGraphPin* OriginalArrayPin = GetTargetArrayPin();
	if (OriginalArrayPin == nullptr || OriginalArrayPin->LinkedTo.Num() == 0)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("K2Node_ArraySort_Error", "ArraySort must have a Array specified.").ToString(), this);
		// we break exec links so this is the only error we get
		BreakAllNodeLinks();
		return;
	}
	const FName DstFunctionName = GET_FUNCTION_NAME_CHECKED(UAwesomeFunctionLibrary, Array_SortV2);
	UK2Node_CallFunction* DstArraySortFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	DstArraySortFunction->FunctionReference.SetExternalMember(DstFunctionName, UAwesomeFunctionLibrary::StaticClass());
	DstArraySortFunction->AllocateDefaultPins();

	const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(GetSchema());
	const FEdGraphPinType& OriginalArrayPinType = OriginalArrayPin->PinType;

	UEdGraphPin* DstArrayPin = DstArraySortFunction->FindPinChecked(ArraySortHelper::TargetArrayPinName);
	FEdGraphPinType& DstArrayPinType = DstArrayPin->PinType;

	DstArrayPinType.PinCategory = OriginalArrayPinType.PinCategory;
	DstArrayPinType.PinSubCategory = OriginalArrayPinType.PinSubCategory;
	DstArrayPinType.PinSubCategoryObject = OriginalArrayPinType.PinSubCategoryObject;
	CompilerContext.MovePinLinksToIntermediate(*OriginalArrayPin, *DstArrayPin);

	UEdGraphPin* DstPropertyNamePin = DstArraySortFunction->FindPinChecked(ArraySortHelper::PropertyNamePinName);
	CompilerContext.MovePinLinksToIntermediate(*GetPropertyNamePin(), *DstPropertyNamePin);

	UEdGraphPin* DstAscendingPinPin = DstArraySortFunction->FindPinChecked(ArraySortHelper::AscendingPinName);
	CompilerContext.MovePinLinksToIntermediate(*GetAscendingPinPin(), *DstAscendingPinPin);

	CompilerContext.MovePinLinksToIntermediate(*GetExecPin(), *DstArraySortFunction->GetExecPin());
	UEdGraphPin* DstThenPin = DstArraySortFunction->GetThenPin();
	UEdGraphPin* OriginalThenPin = FindPinChecked(UEdGraphSchema_K2::PN_Then);
	CompilerContext.MovePinLinksToIntermediate(*OriginalThenPin, *DstThenPin);

	BreakAllNodeLinks();
}

FSlateIcon UK2Node_ArraySort::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = GetNodeTitleColor();
	static FSlateIcon Icon("EditorStyle", "Kismet.AllClasses.FunctionIcon");
	return Icon;
}

void UK2Node_ArraySort::PostReconstructNode()
{
	Super::PostReconstructNode();

	UEdGraphPin* ArrayPin = GetTargetArrayPin();
	if (ArrayPin->LinkedTo.Num() > 0 && ArrayPin->LinkedTo[0]->PinType.PinCategory != UEdGraphSchema_K2::PC_Wildcard)
	{
		PropagatePinType(ArrayPin->LinkedTo[0]->PinType);
	}
}

void UK2Node_ArraySort::EarlyValidation(class FCompilerResultsLog& MessageLog) const
{
	Super::EarlyValidation(MessageLog);

	//	const UEdGraphPin* TargetArrayPin = GetTargetArrayPin();
	//	const UEdGraphPin* RowNamePin = GetRowNamePin();
	//	if (!TargetArrayPin || !RowNamePin)
	//	{
	//		MessageLog.Error(*LOCTEXT("MissingPins", "Missing pins in @@").ToString(), this);
	//		return;
	//	}
	//
	//	if (TargetArrayPin->LinkedTo.Num() == 0)
	//	{
	//		const UTargetArray* TargetArray = Cast<UTargetArray>(TargetArrayPin->DefaultObject);
	//		if (!TargetArray)
	//		{
	//			MessageLog.Error(*LOCTEXT("NoTargetArray", "No TargetArray in @@").ToString(), this);
	//			return;
	//		}
	//
	//		if (!RowNamePin->LinkedTo.Num())
	//		{
	//			const FName CurrentName = FName(*RowNamePin->GetDefaultAsString());
	//			if (!TargetArray->GetRowNames().Contains(CurrentName))
	//			{
	//				const FString Msg = FText::Format(
	//					LOCTEXT("WrongRowNameFmt", "'{0}' row name is not stored in '{1}'. @@"),
	//					FText::FromString(CurrentName.ToString()),
	//					FText::FromString(GetFullNameSafe(TargetArray))
	//				).ToString();
	//				MessageLog.Error(*Msg, this);
	//				return;
	//			}
	//		}
	//	}
}


void UK2Node_ArraySort::PropagatePinType(FEdGraphPinType& InType)
{
	UBlueprint const* Blueprint = GetBlueprint();

	UClass const* CallingContext = NULL;
	if (Blueprint)
	{
		CallingContext = Blueprint->GeneratedClass;
		if (CallingContext == NULL)
		{
			CallingContext = Blueprint->ParentClass;
		}
	}

	const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
	UEdGraphPin* ArrayPin = GetTargetArrayPin();

	ArrayPin->PinType = InType;
	ArrayPin->PinType.ContainerType = EPinContainerType::Array;
	ArrayPin->PinType.bIsReference = true;

	// Verify that all previous connections to this pin are still valid with the new type
	for (TArray<UEdGraphPin*>::TIterator ConnectionIt(ArrayPin->LinkedTo); ConnectionIt; ++ConnectionIt)
	{
		UEdGraphPin* ConnectedPin = *ConnectionIt;
		if (!Schema->ArePinsCompatible(ArrayPin, ConnectedPin, CallingContext))
		{
			ArrayPin->BreakLinkTo(ConnectedPin);
		}
		else if (ConnectedPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
		{
			if (UK2Node* ConnectedNode = Cast<UK2Node>(ConnectedPin->GetOwningNode()))
			{
				ConnectedNode->PinConnectionListChanged(ConnectedPin);
			}
		}
	}
	RefreshPropertyNameOptions();
}


void UK2Node_ArraySort::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	UEdGraphPin* ArrayPin = GetTargetArrayPin();
	if (Pin == ArrayPin)
	{
		const bool bConnectionAdded = Pin->LinkedTo.Num() > 0;
		if (bConnectionAdded)
		{
			const bool bIsWildcard = (ArrayPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard);
			if (bIsWildcard)
			{
				FEdGraphPinType& NewType = Pin->LinkedTo[0]->PinType;
				if (NewType.PinCategory != UEdGraphSchema_K2::PC_Wildcard)
				{
					PropagatePinType(NewType);
				}
			}
		}
		else
		{
			UEdGraphPin* PropertyNamePin = GetPropertyNamePin();
			if (PropertyNamePin && PropertyNamePin->LinkedTo.Num() == 0)
			{
				GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(PropertyNamePin);
			}
			ArrayPin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			ArrayPin->PinType.PinSubCategory = NAME_None;
			ArrayPin->PinType.PinSubCategoryObject = nullptr;
			ArrayPin->BreakAllPinLinks();

			RefreshPropertyNameOptions();
		}
	}
}


#undef LOCTEXT_NAMESPACE
